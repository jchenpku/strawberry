/*
 * fasta.cpp
 *
 *  Created on: Jan 23, 2015
 *      Author: ruolin
 */

#include "fasta.h"
#include "common.h"
#include <dirent.h>
#include <assert.h>
#include <stdio.h>
#include <iostream>

// for now this function free whole sequence and setup a
// new _my_subseq object for FaSeqGetter. This is not an efficient way.
void SubSeq::setup(uint s, uint l){
    if (_sequence){ // if not empty
       delete [] _sequence;
    };
   _subseq_start = s;
   _subseq_len = l;
   _sequence = new char[l+1];
}

//initialize .fa file and .fai file name
FaIndex::FaIndex(const char* fname, const char* finame){
   if(fileExists(fname) != 2) SError("Error: fasta file %s not found!\n", fname);
   if (fileSize(fname)<=0) SError("Error: invalid fasta file %s !\n",fname);
   _fa_name.assign(fname);
   if(finame) {
      _fai_name.assign(finame);
      if(fileExists(finame) == 2 and fileSize(finame) > 0){
         loadIndex();
      } else{
         buildIndex();
      }
   }
}

int FaIndex::num_records() const { return _records.size();}
int FaIndex::loadIndex(){
   _records.clear();
   _haveFai = false;
   FILE* fi = fopen(_fai_name.c_str(), "rb");
   if(!fi){
      SMessage("Warning: cannot open fasta index file for reading./n",_fai_name.c_str());
      return 0;
   }
   SlineReader fl(fi);
   char* line = nullptr;
   while( (line = fl.nextLine()) != nullptr ){
      if(*line == '#') continue;
      size_t idx = strcspn(line, " \t");
      if(idx == strlen(line)) SError("Error parsing fasta index line: \n%s\n",line);
      char *p = (char*)(line+idx); //s now holds the genomic sequence name
      *(p++) = 0;
      uint len=0;
      int line_len=0, bline_len=0;
      #ifdef __WIN32__
         long offset = -1;
         sscanf(p, "%d%ld%d%d", &len, &offset, &line_len, &bline_len);
      #else
         long long offset = -1;
         sscanf(p, "%d%lld%d%d", &len, &offset, &line_len, &bline_len);
      #endif
      if(len==0 || line_len==0 || bline_len==0 || line_len > bline_len)
         SError("Error parsing fasta index line: \n%s\n",line);
      #ifdef DEBUG
         printf("%s\t%d\t%lld\t%d\t%d\n", line, len ,offset, line_len, bline_len);
      #endif
      add_record(line, len ,offset, line_len, bline_len);
   }
   fclose(fi);
   return _records.size();

}
// NEED to be done. Currently faIdx is generated by samtools.
int FaIndex::buildIndex(){
   return 0;
}

const string FaIndex::get_faidx_name() const {return _fai_name;}

bool FaIndex::add_record(const string seqname, const uint seqlen, const off_t fpos, const int linelen, const int lineblen){
   pair<FaRecord_p, bool> res;
   res = _records.insert( make_pair(seqname, FaRecord(seqname, seqlen, fpos, linelen, lineblen) ) );
   if(!res.second){
      SMessage("duplicated seqname %s in fasta index file./n", seqname.c_str());
   }

   return res.second;
}

bool FaIndex::getRecord(const string seqname, FaRecord &got){
   auto it = _records.find(seqname);
   if(it !=  _records.end()){
      got = it->second;
      return true;
   }
   return false;
}

void FaSeqGetter::initial(const string fname, const FaRecord &rec)
{
   _fname = fname;
   _my_record = rec;
   fh = fopen(fname.c_str(),"rb");
}

string FaSeqGetter::get_fname() const {return _fname;}

uint FaSeqGetter::loadSeq(uint start, uint len){
   // get faIdx info from record
   //start is 1-based genomic coordinate within current fasta sequence
   int line_len = _my_record._line_len;
   int line_blen = _my_record._line_blen;
   int line_endlen = line_blen - line_len;
   off_t orig_start = _my_record._fpos;
   uint seq_len = _my_record._seq_len;

   if(seq_len == 0){
      SError("Error: empty or zero-length fasta record %s\n", _my_record._seq_name.c_str());
   }
   uint start_line_number = (start-1) / line_len;
   int start_char_in_line = (start-1) % line_len;
   off_t f_start = orig_start + (start_line_number*line_blen) + start_char_in_line;
   uint toread = len;
   if(toread == 0) toread = seq_len - start +1;
   if(toread > MAX_LEN_TO_READ) toread = MAX_LEN_TO_READ;

   _my_subseq.setup(start, toread);
   //assert(start >= _my_subseq._subseq_start);
   char* cur_char_p = _my_subseq._sequence;
   fseeko(fh, f_start, SEEK_SET);
   int act_read_len = 0;
   uint already_read_len = 0;
   if(start_char_in_line > 0){ // read first line (partially if indeed)
      int should_read_len = line_len - start_char_in_line;
      if (should_read_len > toread) should_read_len = toread; // in case we need just a few chars
      act_read_len = fread((void*)cur_char_p, 1, should_read_len, fh);
      if( act_read_len < should_read_len){
         SError("Warning: reading %s encountered a premature eof. Please check input.\n", _fname.c_str());
      }
      toread -= act_read_len;
      cur_char_p += act_read_len;
      already_read_len += act_read_len;
      fseeko(fh, line_endlen, SEEK_CUR);
   }
   while(toread >= line_len){
      act_read_len = fread((void*)cur_char_p, 1, line_len, fh);
      if(act_read_len < line_len){
         SError("Warning: reading %s encountered a premature eof. Please check input.\n", _fname.c_str());
      }
      toread -= act_read_len;
      cur_char_p += act_read_len;
      already_read_len += act_read_len;
      fseeko(fh, line_endlen, SEEK_CUR);
   }
   if(toread>0){ // read last line
      act_read_len = fread((void*)cur_char_p, 1, toread, fh);
      if(act_read_len < toread){
         SError("Warning: reading %s encountered a premature eof. Please check input.\n", _fname.c_str());
      }
      already_read_len += act_read_len;
   }

   return already_read_len;
}

char* FaSeqGetter::fetchSeq(uint start, uint len){
   char * str = new char[len+1];
   strncpy(str, _my_subseq._sequence+start-1, len);
   str[len] = 0;
   return str;
}


FaInterface::FaInterface(const char* fpath){
   if(!fpath) SError("Error: unspecified fasta file or directory\n");
   _fa_path.assign(fpath);
   pair<ItFaidx, bool> ret;
   switch(fileExists(fpath)){
   case 0:
      SError("Error: file or directory %s does not exist!\n",fpath);
      break;
   case 2: // is a file. One file multiple chromosomes.
      // if .fai file is given instead of .fa


      if(endsWith(_fa_path,".fai") ){
         string fa_name = _fa_path.substr(0, _fa_path.length()-4);
         if(!fileExists(fa_name.c_str() )  ){
            SError("Error: Cannot find fasta file for index file %s \n",fpath);
         }else{
            ret = _fa_indexes.insert(make_pair(fa_name, unique_ptr<FaIndex> (new FaIndex(fa_name.c_str(), fpath) ) ) );
            assert(ret.second);
         }
      } else if(endsWith(_fa_path, ".fa") || endsWith(_fa_path, ".fasta")){
         string fai_name = _fa_path+".fai";
         ret = _fa_indexes.insert(make_pair(string(fpath), unique_ptr<FaIndex>(new FaIndex(fpath, fai_name.c_str()) ) )  );
         assert(ret.second);

      } else {
         SError("Error: Cannot find .fasta or .fa file.\n");
      }

      // this for loop initialize _seqname_2_fafile object
      for(auto it_rec = ret.first->second->_records.begin(); it_rec != ret.first->second->_records.end(); ++it_rec){
         pair<unordered_map<string, string>::iterator, bool> ret_it;
         ret_it = _seqname_2_fafile.insert(make_pair(it_rec->first, ret.first->first));
         if(!ret_it.second){
            SError("Error: please checking fasta file %s for possible duplicated sequence names.\n", ret.first->first.c_str());
         }
      }//end for loop

      break;
   case 1:  // is a directory. one file one chromosome.
      DIR *dir;
      struct dirent *ent;
      dir = opendir(fpath);
      while((ent = readdir(dir)) != NULL){
         if(endsWith(ent->d_name, ".fa") || endsWith(ent->d_name, ".fasta")){
            char fai_name[200];
            fai_name[0] = 0;
            strcat(fai_name, fpath);
            if(!endsWith(fpath, "/")) strcat(fai_name,"/");
            strcat(fai_name, ent->d_name);
            string fa_name(fai_name);
            strcat(fai_name, ".fai");
            if(strlen(fai_name) > 199) SError("file name is too long %s.\n", fai_name);
            // if index file exists
            if( fileExists(fai_name) ==2 ) {
               ret = _fa_indexes.insert(make_pair(fa_name, unique_ptr<FaIndex>(new FaIndex(fa_name.c_str(), fai_name) ) )  );
               assert(ret.second);
               // this for loop initialize _seqname_2_fafile object
               for(auto it_rec = ret.first->second->_records.begin(); it_rec != ret.first->second->_records.end(); ++it_rec){
                  pair<unordered_map<string, string>::iterator, bool> ret_it;
                  ret_it = _seqname_2_fafile.insert(make_pair(it_rec->first, ret.first->first));
                  if(!ret_it.second){
                     SError("Error: please checking fasta file %s for possible duplicated sequence names.\n", ret.first->first.c_str());
                  }
               }//end for loop
            }
//            #ifdef DEBUG
//               printf("index file: %s\n", fai_name);
//            #endif
         }
      }
      break;
   default:
      SError("Error: not a valid file or directory!\n", fpath);
      break;
   }
}

void FaInterface::load2FaSeqGetter(FaSeqGetter &getter, const string seqname){
   auto it_fa_name = _seqname_2_fafile.find(seqname);
   assert(it_fa_name != _seqname_2_fafile.end());
   string fa_name = it_fa_name->second;
   auto it_faidx = _fa_indexes.find(fa_name);
   assert(it_faidx != _fa_indexes.end());
   FaRecord rec;
   if(it_faidx->second->getRecord(seqname, rec))
      getter.initial(fa_name, rec);
   else
      SMessage("fetching seq name %s failed.\n", seqname.c_str());
}
